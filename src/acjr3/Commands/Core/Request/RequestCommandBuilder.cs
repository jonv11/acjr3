using System.CommandLine;

namespace Acjr3.Commands.Core;

public static class RequestCommandBuilder
{
    public static Command Build(IServiceProvider services)
    {
        var command = new Command(
            "request",
            "Execute a Jira REST API request. For example: acjr3 request GET /rest/api/3/myself.");
        var methodArg = new Argument<string?>("method") { Description = "HTTP method: GET|POST|PUT|DELETE|PATCH", Arity = ArgumentArity.ZeroOrOne };
        var pathArg = new Argument<string?>("path") { Description = "Relative Jira path (for example, /rest/api/3/myself)", Arity = ArgumentArity.ZeroOrOne };

        var queryOpt = new Option<string[]>("--query") { Description = "Query parameter key=value. Repeat for additional values.", AllowMultipleArgumentsPerToken = true };
        var headerOpt = new Option<string[]>("--header") { Description = "Header key=value. Repeat for additional values.", AllowMultipleArgumentsPerToken = true };
        var acceptOpt = new Option<string>("--accept") { DefaultValueFactory = _ => "application/json", Description = "Accept header value." };
        var contentTypeOpt = new Option<string?>("--content-type") { Description = "Content-Type header value." };
        var inOpt = new Option<string?>("--in") { Description = "Path to request payload file, or '-' for stdin." };
        var outOpt = new Option<string?>("--out") { Description = "Write response body to file path." };
        var allowNonSuccessOpt = new Option<bool>("--allow-non-success") { Description = "Allow 4xx/5xx responses without forcing a non-zero exit." };
        var verboseOpt = new Option<bool>("--verbose") { Description = "Enable verbose diagnostics logging." };
        var debugOpt = new Option<bool>("--debug") { Description = "Enable debug diagnostics." };
        var traceOpt = new Option<bool>("--trace") { Description = "Emit request/response trace diagnostics to stderr." };
        var retryNonIdempotentOpt = new Option<bool>("--retry-non-idempotent") { Description = "Allow retries for POST/PATCH methods." };
        var paginateOpt = new Option<bool>("--paginate") { Description = "Paginate GET requests using Jira values/startAt flow." };
        var explainOpt = new Option<bool>("--explain") { Description = "Show request endpoint and payload without executing." };
        var requestFileOpt = new Option<string?>("--request-file") { Description = "Write generated request payload and metadata to file." };
        var replayOpt = new Option<string?>("--replay") { Description = "Replay a request file generated by --request-file." };
        var yesOpt = new Option<bool>("--yes") { Description = "Confirm mutating operations." };
        var forceOpt = new Option<bool>("--force") { Description = "Force mutating operations." };

        command.AddArgument(methodArg);
        command.AddArgument(pathArg);
        command.AddOption(queryOpt);
        command.AddOption(headerOpt);
        command.AddOption(acceptOpt);
        command.AddOption(contentTypeOpt);
        command.AddOption(inOpt);
        command.AddOption(outOpt);
        command.AddOption(allowNonSuccessOpt);
        command.AddOption(verboseOpt);
        command.AddOption(debugOpt);
        command.AddOption(traceOpt);
        command.AddOption(retryNonIdempotentOpt);
        command.AddOption(paginateOpt);
        command.AddOption(explainOpt);
        command.AddOption(requestFileOpt);
        command.AddOption(replayOpt);
        command.AddOption(yesOpt);
        command.AddOption(forceOpt);

        var symbols = new RequestCommandSymbols(
            methodArg,
            pathArg,
            queryOpt,
            headerOpt,
            acceptOpt,
            contentTypeOpt,
            inOpt,
            outOpt,
            allowNonSuccessOpt,
            verboseOpt,
            debugOpt,
            traceOpt,
            retryNonIdempotentOpt,
            paginateOpt,
            explainOpt,
            requestFileOpt,
            replayOpt,
            yesOpt,
            forceOpt);

        command.SetHandler(async context =>
        {
            await RequestCommandHandler.HandleAsync(services, context, symbols);
        });

        return command;
    }
}


