using System.CommandLine;
using System.CommandLine.Invocation;
using System.CommandLine.Parsing;
using Acjr3.Common;
using Microsoft.Extensions.DependencyInjection;

namespace Acjr3.Commands.Core;

public static class RequestCommandBuilder
{
    public static Command Build(IServiceProvider services)
    {
        var command = new Command(
            "request",
            "Execute a Jira REST API request. For example: acjr3 request GET /rest/api/3/myself.");
        var methodArg = new Argument<string?>("method", () => null, "HTTP method: GET|POST|PUT|DELETE|PATCH") { Arity = ArgumentArity.ZeroOrOne };
        var pathArg = new Argument<string?>("path", () => null, "Relative Jira path (for example, /rest/api/3/myself)") { Arity = ArgumentArity.ZeroOrOne };

        var queryOpt = new Option<string[]>("--query", "Query parameter key=value. Repeat for additional values.") { AllowMultipleArgumentsPerToken = true };
        var headerOpt = new Option<string[]>("--header", "Header key=value. Repeat for additional values.") { AllowMultipleArgumentsPerToken = true };
        var acceptOpt = new Option<string>("--accept", () => "application/json", "Accept header value.");
        var contentTypeOpt = new Option<string?>("--content-type", "Content-Type header value.");
        var bodyOpt = new Option<string?>("--body", "Inline JSON request payload (JSON object).");
        var bodyFileOpt = new Option<string?>("--body-file", "Path to JSON request payload file (JSON object).");
        var inOpt = new Option<string?>("--in", "Path to request payload file, or '-' for stdin.");
        var inputFormatOpt = new Option<string>("--input-format", () => "json", "Input format: json|adf|md|text.");
        var outOpt = new Option<string?>("--out", "Write response body to file path.");
        var failOnNonSuccessOpt = new Option<bool>("--fail-on-non-success", () => true, "Return non-zero on 4xx/5xx responses.");
        var verboseOpt = new Option<bool>("--verbose", "Enable verbose diagnostics logging.");
        var debugOpt = new Option<bool>("--debug", "Enable debug diagnostics.");
        var traceOpt = new Option<bool>("--trace", "Emit request/response trace diagnostics to stderr.");
        var retryNonIdempotentOpt = new Option<bool>("--retry-non-idempotent", "Allow retries for POST/PATCH methods.");
        var paginateOpt = new Option<bool>("--paginate", "Paginate GET requests using Jira values/startAt flow.");
        var explainOpt = new Option<bool>("--explain", "Show request endpoint and payload without executing.");
        var requestFileOpt = new Option<string?>("--request-file", "Write generated request payload and metadata to file.");
        var replayOpt = new Option<string?>("--replay", "Replay a request file generated by --request-file.");
        var yesOpt = new Option<bool>("--yes", "Confirm mutating operations.");
        var forceOpt = new Option<bool>("--force", "Force mutating operations.");

        command.AddArgument(methodArg);
        command.AddArgument(pathArg);
        command.AddOption(queryOpt);
        command.AddOption(headerOpt);
        command.AddOption(acceptOpt);
        command.AddOption(contentTypeOpt);
        command.AddOption(bodyOpt);
        command.AddOption(bodyFileOpt);
        command.AddOption(inOpt);
        command.AddOption(inputFormatOpt);
        command.AddOption(outOpt);
        command.AddOption(failOnNonSuccessOpt);
        command.AddOption(verboseOpt);
        command.AddOption(debugOpt);
        command.AddOption(traceOpt);
        command.AddOption(retryNonIdempotentOpt);
        command.AddOption(paginateOpt);
        command.AddOption(explainOpt);
        command.AddOption(requestFileOpt);
        command.AddOption(replayOpt);
        command.AddOption(yesOpt);
        command.AddOption(forceOpt);

        command.SetHandler(async context =>
        {
            var parseResult = context.ParseResult;
            var logger = new ConsoleLogger(
                parseResult.GetValueForOption(verboseOpt)
                || parseResult.GetValueForOption(debugOpt)
                || parseResult.GetValueForOption(traceOpt));

            if (!OutputOptionBinding.TryResolveOrReport(parseResult, context, out var outputPreferences))
            {
                return;
            }

            if (!RuntimeConfigLoader.TryLoadValidatedConfig(requireAuth: true, logger, out var config, out var configError))
            {
                var (exitCode, errorCode) = ConfigErrorClassifier.Classify(configError);
                CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(errorCode, configError, null, null), (int)exitCode);
                return;
            }

            var methodRaw = parseResult.GetValueForArgument(methodArg);
            var path = parseResult.GetValueForArgument(pathArg);
            var replayPath = parseResult.GetValueForOption(replayOpt);
            StoredRequest? replayRequest = null;
            if (!string.IsNullOrWhiteSpace(replayPath))
            {
                var replayLoaded = await RequestRecording.LoadAsync(replayPath!, context.GetCancellationToken());
                if (!replayLoaded.Ok)
                {
                    CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, replayLoaded.Error, null, null), (int)CliExitCode.Validation);
                    return;
                }

                replayRequest = replayLoaded.Request!;
                methodRaw = replayRequest.Method;
                path = replayRequest.Path;
            }

            if (string.IsNullOrWhiteSpace(methodRaw) || string.IsNullOrWhiteSpace(path))
            {
                CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, "Provide METHOD and PATH, or use --replay <file>.", null, null), (int)CliExitCode.Validation);
                return;
            }

            if (!HttpMethodParser.TryParse(methodRaw!, out var httpMethod, out var methodError))
            {
                CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, methodError, null, null), (int)CliExitCode.Validation);
                return;
            }

            if (!RequestOptionParser.TryParsePairs(parseResult.GetValueForOption(queryOpt) ?? [], out var queryPairs, out var queryError))
            {
                CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, queryError, null, null), (int)CliExitCode.Validation);
                return;
            }

            if (!RequestOptionParser.TryParsePairs(parseResult.GetValueForOption(headerOpt) ?? [], out var headerPairs, out var headerError))
            {
                CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, headerError, null, null), (int)CliExitCode.Validation);
                return;
            }

            if (!InputResolver.TryParseFormat(parseResult.GetValueForOption(inputFormatOpt), out var inputFormat, out var formatError))
            {
                CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, formatError, null, null), (int)CliExitCode.Validation);
                return;
            }

            if (!InputResolver.TryResolveExplicitPayloadSource(
                    parseResult.GetValueForOption(inOpt),
                    parseResult.GetValueForOption(bodyOpt),
                    parseResult.GetValueForOption(bodyFileOpt),
                    out var payloadSource,
                    out var payloadSourceError))
            {
                CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, payloadSourceError, null, null), (int)CliExitCode.Validation);
                return;
            }

            string? payloadValue = null;
            var payloadFromDefaultJson = false;
            switch (payloadSource)
            {
                case ExplicitPayloadSource.In:
                {
                    var payloadLoad = await InputResolver.TryReadPayloadAsync(parseResult.GetValueForOption(inOpt), inputFormat, context.GetCancellationToken());
                    if (!payloadLoad.Ok)
                    {
                        CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, payloadLoad.Error, null, null), (int)CliExitCode.Validation);
                        return;
                    }

                    payloadValue = payloadLoad.Payload;
                    break;
                }
                case ExplicitPayloadSource.Body:
                case ExplicitPayloadSource.BodyFile:
                {
                    var bodyLoad = await InputResolver.TryReadBodyPayloadAsync(
                        parseResult.GetValueForOption(bodyOpt),
                        parseResult.GetValueForOption(bodyFileOpt),
                        context.GetCancellationToken());
                    if (!bodyLoad.Ok)
                    {
                        CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, bodyLoad.Error, null, null), (int)CliExitCode.Validation);
                        return;
                    }

                    var optionName = payloadSource == ExplicitPayloadSource.Body ? "--body" : "--body-file";
                    if (!JsonPayloadPipeline.TryParseJsonObject(bodyLoad.Payload!, optionName, out var parsedBody, out var parseBodyError))
                    {
                        CliEnvelopeWriter.Write(context, services, outputPreferences, false, null, new CliError(CliErrorCode.Validation, parseBodyError, null, null), (int)CliExitCode.Validation);
                        return;
                    }

                    payloadValue = JsonPayloadPipeline.Serialize(parsedBody!);
                    break;
                }
                default:
                    break;
            }

            if (replayRequest is not null)
            {
                if (queryPairs.Count == 0 && replayRequest.Query.Count > 0)
                {
                    queryPairs = replayRequest.Query.ToList();
                }

                if (headerPairs.Count == 0 && replayRequest.Headers.Count > 0)
                {
                    headerPairs = replayRequest.Headers.ToList();
                }

                if (string.IsNullOrWhiteSpace(payloadValue) && !string.IsNullOrWhiteSpace(replayRequest.Body))
                {
                    payloadValue = replayRequest.Body;
                }
            }

            if (string.IsNullOrWhiteSpace(payloadValue) && IsMutatingMethod(httpMethod!))
            {
                payloadValue = "{}";
                payloadFromDefaultJson = true;
            }

            var acceptValue = parseResult.GetValueForOption(acceptOpt)!;
            if (replayRequest is not null && !IsOptionSpecified(parseResult, acceptOpt))
            {
                acceptValue = replayRequest.Accept;
            }

            var requestContentType = parseResult.GetValueForOption(contentTypeOpt);
            if (replayRequest is not null
                && string.IsNullOrWhiteSpace(requestContentType)
                && !string.IsNullOrWhiteSpace(replayRequest.ContentType))
            {
                requestContentType = replayRequest.ContentType;
            }

            if (!string.IsNullOrWhiteSpace(payloadValue) && string.IsNullOrWhiteSpace(requestContentType))
            {
                if (payloadFromDefaultJson
                    || payloadSource == ExplicitPayloadSource.Body
                    || payloadSource == ExplicitPayloadSource.BodyFile)
                {
                    requestContentType = "application/json";
                }
                else
                {
                    requestContentType = InputResolver.ContentTypeFor(inputFormat);
                }
            }

            var storedRequest = new StoredRequest(
                httpMethod!.Method,
                path!,
                queryPairs,
                headerPairs,
                acceptValue,
                requestContentType,
                payloadValue);

            var requestFilePath = parseResult.GetValueForOption(requestFileOpt);
            if (!string.IsNullOrWhiteSpace(requestFilePath))
            {
                await RequestRecording.SaveAsync(requestFilePath!, storedRequest, context.GetCancellationToken());
            }

            if (parseResult.GetValueForOption(explainOpt))
            {
                CliEnvelopeWriter.Write(context, services, outputPreferences, true, new
                {
                    method = storedRequest.Method,
                    path = storedRequest.Path,
                    query = storedRequest.Query,
                    headers = storedRequest.Headers.Select(h => new { key = h.Key, value = Redactor.RedactHeader(h.Key, h.Value) }),
                    contentType = storedRequest.ContentType,
                    body = storedRequest.Body,
                    requestFile = requestFilePath
                }, null, (int)CliExitCode.Success);
                return;
            }

            var options = new RequestCommandOptions(
                httpMethod,
                path!,
                queryPairs,
                headerPairs,
                acceptValue,
                requestContentType,
                payloadValue,
                parseResult.GetValueForOption(outOpt),
                outputPreferences,
                parseResult.GetValueForOption(failOnNonSuccessOpt),
                parseResult.GetValueForOption(retryNonIdempotentOpt),
                parseResult.GetValueForOption(paginateOpt) || outputPreferences.All,
                parseResult.GetValueForOption(yesOpt) || parseResult.GetValueForOption(forceOpt));

            var executor = services.GetRequiredService<RequestExecutor>();
            context.ExitCode = await executor.ExecuteAsync(config!, options, logger, context.GetCancellationToken());
        });

        return command;
    }

    private static bool IsOptionSpecified<T>(ParseResult parseResult, Option<T> option)
    {
        return parseResult.FindResultFor(option) is OptionResult { Tokens.Count: > 0 };
    }

    private static bool IsMutatingMethod(HttpMethod method)
    {
        return method == HttpMethod.Post
            || method == HttpMethod.Put
            || method.Method.Equals("PATCH", StringComparison.OrdinalIgnoreCase);
    }
}
